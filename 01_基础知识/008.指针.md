## 1.运算符&
- 获得变量的地址，他的操作数必须是变量
- 地址的大小是否与int相同取决于编译器和系统架构(32位64位)
```c
int i;
printf("%p",&i);
```
## 2.指针
- 就是保存地址的变量，scanf获取的就是变量地址
## 3.访问那个地址上的变量
- *是一个单目运算符，用来访问指针的值所表示的地址上的变量，可以做左值，也可以做右值
> 左值之所以叫左值：
是因为出现在赋值号左边的不是变量，而是值，是表达式计算的结果
> a[0]=2; *p=5;是特殊的值,所以叫做左值
## 4.指针应用场景
- 交换两个变量的值
- 函数返回多个值,某些值就只能通过指针返回,传入的参数实际上就是需要保存带回的变量
- 常见错误: 定义了指针变量,还没有指向变量,就开始使用指针
## 5.传入函数的数组成了什么
- 函数参数表中的数组实际上是指针
- 数组变量是特殊的指针,数组变量本身表达地址,所以int a[10]; int *p=a;//无需用&取地址
- 但是数组的单元表达的是变量,需要用&取地址 a==&a[0]
- []可以对数组做,也可以对指针做
- *可以对指针做,也可以对数组做
- 数组变量是const的指针,所以不能赋值， int a[] ==> int * const a
## 6.指针与const
- 指针是const: 表示一旦得到了某个变量的地址，不能再指向其他变量，int * const q = &a; 
- 所指是const：表示不能通过这个指针去修改那个变量（并不能使得那个变量成为const）
```c
const int *p = &i;
*p = 25;//错误
i = 25;//OK
p = &j;//OK
```
- 判断哪个被const的标志是const在*的前面还是后面 
## 7.指针运算
- 指针加一的操作实际上是把他所指移向下一个单元，例如
```c
int a[] = {1,2,3};
int *p = a;
printf("p  =%p", p);
printf("p+1=%p", p+1);//实际输出的地址应该比前一个多了sizeof(int),就是一个单元的大小
```
- 两个指针相减，得到的是两个指针之间有几个单元，而不是地址之差，是地址之差/sizeof()
- *p++,++运算符较高，p++的结果值是p,因此表示取出p所指的数，指向下一个地址
- 0地址，NULL是一个预定义的符号，表示0地址
## 8.指针的类型
- 无论指向什么类型，所有的指针的大小都是一样的，因为都是地址
- 指向不同类型的指针是不能直接互相赋值的
## 9.动态内存分配
- C99前，要获取一个不定长的数组，可以使用动态内存分配 malloc(count_t),返回 void *,参数为字节长度
```c
#include <stdio.h>
#include <stdlib.h>
int main() {
    int number;
    printf("请输入数量：\n");
    scanf("%d", &number);
    printf("number=%d",number);
    int *p;
	p = (int*)malloc(number*sizeof(int));
    for(int i=0;i<number;i++) {
        scanf("%d", &p[i]);
    }
    for(int j=0;j<number;j++) {
        printf("%d", p[j]);
    }
    free(p);
    return 0;
}
```
## 10.问题
```c
char *p;
while (1) {
    p = malloc(1);
    *p = 0;
}
```
> 最终程序会因为向0地址写入而退出
> while（1）这句运行的话程序就一直会分配内存，这样肯定会引起内存耗尽。进而malloc会分配内存失败，但是失败时并不会终止程序，`而是返回NULL指针`。但是*p = 0;代码试图向NULL指针位置写入数据，这样就会引起程序终止，这就是最终程序会因为向0地址写入而退出，这里0地址可以理解为NULL地址