- C语言中用%%打印输出字符%,所以%%d，输出为%d
```c
int a=2;
printf("a=%%d",a); //a=%d
```
- 在c语言中，逻辑真值对应`非0`,逻辑假值对应0；对于浮点变量a,b,表达式a == b是合法的
- for语句的圆括号中的表达式可以全部省略，但是需要保留两个;  for(;;) 等价于 while(1)
----------字符串-----------
```c
int main() {
	//字符串
	char name[10] = "Hello";
//	char name[10];
//	name = "Hello"; //错误，不能对字符数组直接赋值

	//对比scanf与getchar读取字符 https://blog.csdn.net/xiao_yanci/article/details/80588934
//	char ch1, ch2;
//	scanf("%c", &ch1);
//	scanf("%c", &ch2);
//	printf("%d  %d\n", ch1, ch2);
//	char ch3, ch4;
//	ch3 = getchar();
//	ch4 = getchar();
//	printf("%d  %d\n", ch3, ch4);
	//scanf()和getchar()函数是从输入流缓冲区中读取值的，
	//而并非从键盘(也就是终端)缓冲区读取。而读 取时遇到回车(\n)而结束的，这个\n会一起读入输入流缓冲区的，
	//所以第一次接受输入时取走字符后会留下字符\n，这样第二次的读入函数直接从缓冲区中 把\n取走了，显然读取成功了，所以不会再从终端读取！ 
	//对比scnaf与gets读取字符串
//	char str1[20], str2[20];
//	scanf("%s",str1);//用scanf来读取一个字符串时，字符串中是不可以出现空格的，一旦出现空格，后面的数据就会舍弃残留在缓冲区中。 
//	printf("%s\n",str1);
//	scanf("%s",str2);
//	printf("%s\n",str2);
//	char str1[20], str2[20];
//	gets(str1);//另外一个函数是可以接受空格的，那就是gets() 
//	printf("%s\n",str1);
//	gets(str2);
//	printf("%s\n",str2);

	//指针变量所占用的大小,取决于编译器和系统架构
	char *a = "hello";
	printf("%d\n",sizeof(a));
	printf("%d\n",strlen(a));
	double *b;
	printf("%d\n",sizeof(b)); 
	int *c;
	printf("%p---%p\n",c,(c+1));
	return 0;
}

```
---------- 结束------------
- sizeof 求出字符串的字符个数，包括结尾符，strlen求出实际字符，不包括结尾符

![2020-03-28_153007.png](http://ww1.sinaimg.cn/large/005SzfLuly1gd9oew2nwdj30om0j3my9.jpg)

- 优先级

![2020-03-28_153649.png](http://ww1.sinaimg.cn/large/005SzfLuly1gd9okddm94j30lh0ok0tg.jpg)

- scanf是标准库函数名，可以用作用户标识符，只是在是使用的地方不能包含srdio.h头文件
- printf()函数格式化字符串的一般形式为：【标志】【输出最小宽度】【精度】【长度】类型
- 十六进制的数码取值为0-9,A-F或a-f,前缀为0X或0x，在C程序中只有十进制数可以是负数，而八进制和十六进制只能是整数
- 对于空返回值的函数，为了在函数题的任意位置退出，可以使用return语句，只是return后不用加返回值
- 求模运算符%的操作数只能是整数
- 实数有两种形式：十进制小数形式和指数形式。指数形式一般为：aEn,a为十进制数，n为十进制数，表示：a*10^n,当a为0.x是可以简写成.x，但是n不能省略，即使为0。
- 标识符分为关键字、预定义标识符、用户标识符，关键字不可以作为用户标识符，预定义标识符可以作为用户标识符，但是会被覆盖，可能导致运行错误。
- scanf()函数格式字符串的一般形式为:%[*][输入数据宽度][长度]类型，输入数据宽度必须是十进制整数，他没有精度控制，因此%4.2f是错误的。%lf表示用小数形式输入双精度浮点数，%le表示用指数形式输入双精度浮点数
- switch(表达式)switch后面的表达式只能是整型或者字符型，case后面必须是常量表达式
- 对于二维数组，如果一维的长度没有指定，则定义的同时需要完成初始化，否则不知道分配多大的内存空间，如int a[][3];就是错误的。若完成初始化的二维数组，第一维的长度没有指定，则第一维的长度按如下规则确定：若初值个数能被第二维大小整除，所得的商就是第一维的大小，否则商加1就是第一维的大小，如int a[][3]={111};第一维的大小就是1/3 + 1 = 1
- C语言中函数的说明形式为：类型说明符 函数名（类型 形参名），形参名可以省略，但是类型不可以省略
- 字符数组只能在初始化的时候赋值，负责只能对数组元素逐个赋值，如：char a[7] = "string";//对  char b[7];b="string";//错误。与纳音在于数组变量是const的指针,所以不能赋值， int a[] ==> int * const a  指针是const: 表示一旦得到了某个变量的地址，不能再指向其他变量
- 逗号表达式：一般形式为 表达式1,表达式2 并以表达式2的值作为整个逗号表达式的值；但是逗号运算符优先级最低，所以基本没啥用
- 赋值表达式是一种表达式，它可以出现在任何允许表达式出现的地方，而赋值语句则不能。 下述语句是合法的： if((x=y+5)>0) z=x;下述语句是非法的： if((x=y+5;)>0) z=x; 因为x=y+5;是语句，不能出现在表达式中。
- printf函数调用的一般形式为： printf(“格式控制字符串”，输出表列) 其中格式控制字符串用于指定输出格式。格式控制串可由格式字符串和非格式字符串两种组成。格式字符串是以%开头的字符串，在%后面跟有各种格式字符，以说明输出数据的类型、形式、长度、小数位数等。如： “%d”表示按十进制整型输出； “%ld”表示按十进制长整型输出； “%c”表示按字符型输出等。 非格式字符串在输出时原样照印，在显示中起提示作用。

![2020-03-30_231029.png](http://ww1.sinaimg.cn/large/005SzfLuly1gdccx4gdfyj30px0nkjwd.jpg)

- printf函数对输出表中各量求值的顺序是自右至左进行的,因此
```c
int i=8; 
printf("%d\n%d\n%d\n%d\n%d\n%d\n",++i,--i,i++,i--,-i++,-i--); 
//变量求值顺序为-i--=-8,-i++=-7
//但是必须注意，求值顺序虽是自右至左，但是输出顺序还是从左至右
```
- 使用scanf函数还必须注意以下几点：
1) scanf函数中没有精度控制，如：scanf("%5.2f",&a);是非法的。不能企图用此语句输入小数为2位的实数。
2) scanf中要求给出变量地址，如给出变量名则会出错。如 scanf("%d",a);是非法的，应改为scnaf("%d",&a);才是合法的。
3) 在输入多个数值数据时，若格式控制串中没有非格式字符作输入数据之间的间隔则可用空格，TAB或回车作间隔。C编译在碰到空格，TAB，回车或非法数据(如对“%d”输入“12A”时，A即为非法数据)时即认为该数据结束。
4) 在输入字符数据时，若格式控制串中无非格式字符，则认为所有输入的字符均为有效字符。例如： scanf("%c%c%c",&a,&b,&c); 输入为： d e f 则把'd'赋予a, ' ' 赋予b,'e'赋予c。 只有当输入为： def 时，才能把'd'赋于a,'e'赋予b,'f'赋予c。
- 注意在变量说明中给变量赋初值和赋值语句的区别。
给变量赋初值是变量说明的一部分，赋初值后的变量与其后的其它同类变量之间仍必须用逗号间隔，而赋值语句则必须用分号结尾。
- 注意赋值表达式和赋值语句的区别。
赋值表达式是一种表达式，它可以出现在任何允许表达式出现的地方，而赋值语句则不能。 下述语句是合法的： if((x=y+5)>0) z=x; 语句的功能是，若表达式x=y+5大于0则z=x。 下述语句是非法的： if((x=y+5;)>0) z=x; 因为x=y+5;是语句，不能出现在表达式中。
```c
define FD 5
int n = 4;
int a[n] = {1,2,3};//[Error] 数组大小不能用变量 
int b[FD];//但是可以是符号常数或常量表达式
```
- 数组元素的一般形式为：     数组名[下标] 其中下标只能为整型常量或整型表达式。如为小数时，C 编译将自动取整。 
- 应该说明的是，对一个字符数组，如果不作初始化赋值，则必须说明数组长度。还应该特别注意的是，当用scanf函数输入字符串时，字符串中不能含有空格，否则将以空格作为串的结束符。gets函数并不以空格作为字符串输入结束的标志，而只以回车作为输入结束。这是与scanf函数不同的。
- 关于函数的返回值，如函数值为整型，在函数定义时可以省去类型说明。如main(){}
- Ｃ语言中又规定在以下几种情况时可以省去主调函数中对被调函数的函数说明。1) 如果被调函数的返回值是整型或字符型时，可以不对被调函数作说明，而直接调用。这时系统将自动对被调函数返回值按整型处理。例8.2的主函数中未对函数s作说明而直接调用即属此种情形。
```c
main() { 
	int n; 
	printf("input number\n"); 
	scanf("%d",&n); s(n); 
	printf("n=%d\n",n); 
} 
int s(int n) { 
	int i; 
	for(i=n-1;i>=1;i--) n=n+i; 
	printf("n=%d\n",n); 
}
```
- 前面已经讨论过，在变量作函数参数时，所进行的值传送是单向的。即只能从实参传向形参，不能从形参传回实参。形参的初值和实参相同，而形参的值发生改变后，实参并不变化，两者的终值是不同的。而当用数组名作函数参数时，情况则不同。由于实际上形参和实参为同一数组，因此当形参数组发生变化时，实参数组也随之变化。当然这种情况不能理解为发生了“双向”的值传递。但从实际情况来看，调用函数之后实参数组的值将由于形参数组值的变化而变化。
- 在函数形参表中，允许不给出形参数组的长度，或用一个变量来表示数组元素的个数。
例如，可以写为： void nzp(int a[]) 或写为 void nzp(int a[]，int n) 其中形参数组a没有给出长度，而由n值动态地表示数组的长度。n的值由主调函数的实参进行传送。
- 对静态局部变量的说明：
1) 静态局部变量属于静态存储类别，在静态存储区内分配存储单元。在程序整个运行期间都不释放。而自动变量（即动态局部变量）属于动态存储类别，占动态存储空间，函数调用结束后即释放。
2) 静态局部变量在编译时赋初值，即只赋初值一次；而对自动变量赋初值是在函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语句。
3) 如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符（对字符变量）。而对自动变量来说，如果不赋初值则它的值是一个不确定的值。
- 为了提高效率，C语言允许将局部变量得值放在CPU中的寄存器中，这种变量叫“寄存器变量”，用关键字register作声明。说明：
1) 只有局部自动变量和形式参数可以作为寄存器变量；
2) 一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量；
3) 局部静态变量不能定义为寄存器变量。
- 对于宏定义还要说明以下几点：
1) 宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单的代换，字符串中可以含任何字符，可以是常数，也可以是表达式，预处理程序对它不作任何检查。如有错误，只能在编译已被宏展开后的源程序时发现。
2) 宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起置换。
3) 宏定义必须写在函数之外，其作用域为`宏定义命令起到源程序结束`。如要终止其作用域可使用# undef命令。
4) 可用宏定义表示数据类型，使书写方便。
例如： #define STU struct stu 在程序中可用STU作变量说明： STU body[5],*p; #define INTEGER int 在程序中即可用INTEGER作整型变量说明： INTEGER a,b; 应注意用宏定义表示数据类型和用typedef定义数据说明符的区别。 宏定义只是简单的字符串代换，是在预处理完成的，而typedef是在编译时处理的，它不是作简单的代换，而是对类型说明符重新命名。被命名的标识符具有类型定义说明的功能。 请看下面的例子： #define PIN1 int * typedef (int *) PIN2; 从形式上看这两者相似， 但在实际使用中却不相同。 下面用PIN1，PIN2说明变量时就可以看出它们的区别： PIN1 a,b;在宏代换后变成: int *a,b; 表示a是指向整型的指针变量，而b是整型变量。
- 对于带参的宏定义有以下问题需要说明： 1. 带参宏定义中，宏名和形参表之间不能有空格出现。 例如把：
#define MAX(a,b) (a>b)?a:b 写为： #define MAX (a,b) (a>b)?a:b 将被认为是无参宏定义，宏名MAX代表字符串 (a,b) (a>b)?a:b。宏展开时，宏调用语句： max=MAX(x,y); 将变为： max=(a,b)(a>b)?a:b(x,y); 这显然是错误的。
- 指针变量的加减运算只能对数组指针变量进行，对指向其它类型变量的指针变量作加减运算是毫无意义的。对于指向数组的指针变量，可以加上或减去一个整数n。设pa是指向数组a的指针变量，则pa+n,pa-n,pa++,++pa,pa--,--pa运算都是合法的。指针变量加或减一个整数n的意义是把指针指向的当前位置(指向某数组元素)向前或向后移动n个位置。应该注意，数组指针变量向前或向后移动一个位置和地址加1或减1在概念上是不同的。因为数组可以有不同的类型，各种类型的数组元素所占的字节长度是不同的。如指针变量加1，即向后移动1 个位置表示指针变量指向下一个数据元素的首地址。而不是在原地址基础上加1。
- 指针变量可以实现本身的值的改变。如p++是合法的；而a++是错误的。因为a是数组名，它是数组的首地址，是常量。（int * const a）
- *p++，由于++和*同优先级，结合方向自右而左，等价于*(p++)。
- 函数指针变量定义的一般形式为： 类型说明符 (*指针变量名)(); 其中“类型说明符”表示被指函数的返回值的类型。“(* 指针变量名)”表示“*”后面的变量是定义的指针变量。最后的空括号表示指针变量所指的是一个函数。 例如： int (*pf)(); 表示pf是一个指向函数入口的指针变量，该函数的返回值(函数值)是整型。
- 调用函数的一般形式为：
(*指针变量名) (实参表) 使用函数指针变量还应注意以下两点：
a) 函数指针变量不能进行算术运算，这是与数组指针变量不同的。数组指针变量加减一个整数可使指针移动指向后面或前面的数组元素，而函数指针的移动是毫无意义的。
b) 函数调用中"(*指针变量名)"的两边的括号不可少，其中的*不应该理解为求值运算，在此处它只是一种表示符号。
- 定义指针型函数的一般形式为： 类型说明符 *函数名(形参表) { …… /*函数体*/ } 其中函数名之前加了“*”号表明这是一个指针型函数，即返回值是一个指针。类型说明符表示了返回的指针值所指向的数据类型。 如： int *ap(int x,int y) { ...... /*函数体*/ } 表示ap是一个返回指针值的指针型函数，它返回的指针指向一个整型变量。
- 应该特别注意的是函数指针变量和指针型函数这两者在写法和意义上的区别。如int(*p)()和int *p()是两个完全不同的量。 int (*p)()是一个变量说明，说明p是一个指向函数入口的指针变量，该函数的返回值是整型量，(*p)的两边的括号不能少。 int *p()则不是变量说明而是函数说明，说明p是一个指针型函数，其返回值是一个指向整型量的指针，*p两边没有括号。作为函数说明，在括号内最好写入形式参数，这样便于与变量说明区别。
- 二维数组指针变量说明的一般形式为： 类型说明符 (*指针变量名)[长度] 其中“类型说明符”为所指数组的数据类型。“*”表示其后的变量是指针类型。“长度”表示二维数组分解为多个一维数组时，一维数组的长度，也就是二维数组的列数。应注意“(*指针变量名)”两边的括号不可少，如缺少括号则表示是指针数组，意义就完全不同了。
- 应该注意指针数组和二维数组指针变量的区别。这两者虽然都可用来表示二维数组，但是其表示方法和意义是不同的。 二维数组指针变量是单个的变量，其一般形式中"(*指针变量名)"两边的括号不可少。而指针数组类型表示的是多个指针(一组有序指针)在一般形式中"*指针数组名"两边不能有括号。 例如： int (*p)[3]; 表示一个指向二维数组的指针变量。该二维数组的列数为3或分解为一维数组的长度为3。 int *p[3] 表示p是一个指针数组，有三个下标变量p[0]，p[1]，p[2]均为指针变量。
- 如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。怎样定义一个指向指针型数据的指针变量呢？如下： char **p;

![2020-04-05_162130.png](http://ww1.sinaimg.cn/large/007TqXN5ly1gdiytdy4fjj30su0oqwgr.jpg)

- 枚举类型在使用中有以下规定：
  枚举值是常量，不是变量。不能在程序中用赋值语句再对它赋值。
例如对枚举weekday的元素再作以下赋值： sun=5; mon=2; sun=mon; 都是错误的。
- 有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1两种状态，用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。 所谓“位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。
1. 位域的定义和位域变量的说明
位域定义与结构定义相仿，其形式为： struct 位域结构名 { 位域列表 }; 其中位域列表的形式为： 类型说明符 位域名：位域长度 例如： struct bs
{ int a:8; int b:2; int c:6; };
- 在Ｃ语言中用一个指针变量指向一个文件，这个指针称为文件指针。通过文件指针就可对它所指的文件进行各种操作。定义说明文件指针的一般形式为： FILE *指针变量标识符； 其中FILE应为大写，它实际上是由系统定义的一个结构，该结构中含有文件名、文件状态和文件当前位置等信息。在编写源程序时不必关心FILE结构的细节。 例如： FILE *fp； 表示fp是指向FILE结构的指针变量，通过fp即可找存放某个文件信息的结构变量，然后按结构变量提供的信息找到该文件，实施对文件的操作。习惯上也笼统地把fp称为指向一个文件的指针。
- fopen函数用来打开一个文件，其调用的一般形式为： 文件指针名=fopen(文件名,使用文件方式); 其中， “文件指针名”必须是被说明为FILE 类型的指针变量； “文件名”是被打开文件的文件名； “使用文件方式”是指文件的类型和操作要求。 “文件名”是字符串常量或字符串数组。 例如： FILE *fp； fp=("file a","r");

![2020-04-05_230423.png](http://ww1.sinaimg.cn/large/007TqXN5ly1gdjagjfwrgj30n80k8acc.jpg)

对于文件使用方式有以下几点说明：
1) 文件使用方式由r,w,a,t,b，+六个字符拼成，各字符的含义是：
r(read): 读 w(write): 写 a(append): 追加 t(text): 文本文件，可省略不写 b(banary): 二进制文件 +: 读和写
2) 凡用“r”打开一个文件时，该文件必须已经存在，且只能从该文件读出。
3) 用“w”打开的文件只能向该文件写入。若打开的文件不存在，则以指定的文件名建立该文件，若打开的文件已经存在，则将该文件删去，重建一个新文件。
4) 若要向一个已存在的文件追加新的信息，只能用“a”方式打开文件。但此时该文件必须是存在的，否则将会出错。
5) 在打开一个文件时，如果出错，fopen将返回一个空指针值NULL。在程序中可以用这一信息来判别是否完成打开文件的工作，并作相应的处理。因此常用以下程序段打开文件：
6) if((fp=fopen("c:\\hzk16","rb")==NULL)
{ printf("\nerror on open c:\\hzk16 file!"); getch(); exit(1); } 这段程序的意义是，如果返回的指针为空，表示不能打开C盘根目录下的hzk16文件，则给出提示信息“error on open c:\ hzk16 file!”，下一行getch()的功能是从键盘输入一个字符，但不在屏幕上显示。在这里，该行的作用是等待，只有当用户从键盘敲任一键时，程序才继续执行，因此用户可利用这个等待时间阅读出错提示。敲键后执行exit(1)退出程序。
7) 把一个文本文件读入内存时，要将ASCII码转换成二进制码，而把文件以文本方式写入磁盘时，也要把二进制码转换成ASCII码，因此文本文件的读写要花费较多的转换时间。对二进制文件的读写不存在这种转换。
8) 标准输入文件(键盘)，标准输出文件(显示器)，标准出错输出(出错信息)是由系统打开的，可直接使用。
- 文件一旦使用完毕，应用关闭文件函数把文件关闭，以避免文件的数据丢失等错误。 fclose函数调用的一般形式是： fclose(文件指针)；
例如： fclose(fp); 正常完成关闭文件操作时，fclose函数返回值为0。如返回非零值则表示有错误发生。
- 对文件的读和写是最常用的文件操作。在Ｃ语言中提供了多种文件读写的函数： 
	- 字符读写函数 ：fgetc和fputc 
	- 字符串读写函数：fgets和fputs 
	- 数据块读写函数：fread和fwrite 
	- 格式化读写函数：fscanf和fprinf 
- fgetc函数的功能是从指定的文件中读一个字符，函数调用的形式为： 字符变量=fgetc(文件指针)； 例如： ch=fgetc(fp);在文件内部有一个位置指针。用来指向文件的当前读写字节。在文件打开时，该指针总是指向文件的第一个字节。使用fgetc 函数后，该位置指针将向后移动一个字节。 因此可连续多次使用fgetc函数，读取多个字符。
- fputc函数的功能是把一个字符写入指定的文件中，函数调用的形式为： fputc(字符量，文件指针)； 其中，待写入的字符量可以是字符常量或变量，例如： fputc('a',fp); 其意义是把字符a写入fp所指向的文件中。对于fputc函数的使用也要说明几点：
1) 被写入的文件可以用写、读写、追加方式打开，用写或读写方式打开一个已存在的文件时将清除原有的文件内容，写入字符从文件首开始。如需保留原有文件内容，希望写入的字符以文件末开始存放，必须以追加方式打开文件。被写入的文件若不存在，则创建该文件。
2) 每写入一个字符，文件内部位置指针向后移动一个字节。
3) fputc函数有一个返回值，如写入成功则返回写入的字符，否则返回一个EOF。可用此来判断写入是否成功。
- rewind函数用于把fp所指文件的内部位置指针移到文件头
- 读字符串函数fgets，函数的功能是从指定的文件中读一个字符串到字符数组中，函数调用的形式为： fgets(字符数组名,n,文件指针); 其中的n是一个正整数。表示从文件中读出的字符串不超过 n-1个字符。在读入的最后一个字符后加上串结束标志'\0'。 例如： fgets(str,n,fp); 的意义是从fp所指的文件中读出n-1个字符送入字符数组str中。对fgets函数有两点说明：
1) 在读出n-1个字符之前，如遇到了换行符或EOF，则读出结束。
2) fgets函数也有返回值，其返回值是字符数组的首地址。
- Ｃ语言还提供了用于整块数据的读写函数。可用来读写一组数据，如一个数组元素，一个结构变量的值等。 读数据块函数调用的一般形式为： fread(buffer,size,count,fp); 写数据块函数调用的一般形式为： fwrite(buffer,size,count,fp); 其中: buffer 是一个指针，在fread函数中，它表示存放输入数据的首地址。在fwrite函数中，它表示存放输出数据的首地址。 size 表示数据块的字节数。 count 表示要读写的数据块块数。 fp 表示文件指针。 例如： fread(fa,4,5,fp); 其意义是从fp所指的文件中，每次读4个字节(一个实数)送入实数组fa中，连续读5次，即读5个实数到fa中。
- fscanf函数，fprintf函数与前面使用的scanf和printf 函数的功能相似，都是格式化读写函数。两者的区别在于fscanf函数和fprintf函数的读写对象不是键盘和显示器，而是磁盘文件。 这两个函数的调用格式为： fscanf(文件指针,格式字符串,输入表列); fprintf(文件指针,格式字符串,输出表列); 例如： fscanf(fp,"%d%s",&i,s); fprintf(fp,"%d%c",j,ch);
- 为了解决这个问题可移动文件内部的位置指针到需要读写的位置，再进行读写，这种读写称为随机读写。 实现随机读写的关键是要按要求移动位置指针，这称为文件的定位。
- 移动文件内部位置指针的函数主要有两个，即 rewind 函数和fseek函数。 rewind函数前面已多次使用过，其调用形式为： rewind(文件指针); 它的功能是把文件内部的位置指针移到文件首。 下面主要介绍fseek函数。 fseek函数用来移动文件内部位置指针，其调用形式为： fseek(文件指针,位移量,起始点); 其中： “文件指针”指向被移动的文件。 “位移量”表示移动的字节数，要求位移量是long型数据，以便在文件长度大于64KB 时不会出错。当用常量表示位移量时，要求加后缀“L”。 “起始点”表示从何处开始计算位移量，规定的起始点有三种：文件首，当前位置和文件尾。 其表示方法如下表。

起始点|表示符号|数字表示
---|---|---
文件首|SEEK_SET|0
当前位置|SEEK_CUR|1
文件末尾|SEEK_END|2

例如： fseek(fp,100L,0); 其意义是把位置指针移到离文件首100个字节处。